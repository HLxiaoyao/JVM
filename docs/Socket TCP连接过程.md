## 概念
### send buffer和recv buffer
TCP协议栈维护着两个socket缓冲区send buffer和recv buffer。要通过TCP连接发送出去的数据都先拷贝到send buffer。可能是从用户空间进程的app buffer拷入或者是从内核的kernel buffer拷入，拷入的过程可以是通过send()函数完成或者使用write()函数写入数据，所以也把这个过程称为写数据，相应的send buffer也被称为write buffer。不过send()函数比write()函数更有效率。

然后将send buffer中的数据拷贝到网卡中，由于一端是内存，一端是网卡设备，可以直接使用DMA的方式进行拷贝，无需CPU的参与。也就是说，send buffer中的数据通过DMA的方式拷贝到网卡中并通过网络传输给TCP连接的另一端：接收端。

当通过TCP连接接收数据时，数据肯定是先通过网卡流入的，然后同样通过DMA的方式拷贝到recv buffer中，再通过recv()函数将数据从recv buffer拷入到用户空间进程的app buffer中。

![socket缓存区](media/15958628546869/socket%E7%BC%93%E5%AD%98%E5%8C%BA.jpg)


### 监听套接字和已连接套接字
监听套接字是在服务进程读取配置文件时，从配置文件中解析出要监听的地址、端口，然后通过socket()函数创建的，然后再通过bind()函数将这个监听套接字绑定到对应的地址和端口上。随后，进程/线程就可以通过listen()函数来监听这个端口(严格地说是监控这个监听套接字)。

已连接套接字是在监听到TCP连接请求并三次握手后，通过accept()函数返回的套接字，后续进程/线程就可以通过这个已连接套接字和客户端进行TCP通信。

为了区分socket()函数和accept()函数返回的两个套接字描述符，可以使用listenfd和connfd分别表示监听套接字和已连接套接字。下面就来说明各种函数的作用，分析这些函数，也是在连接、断开连接的过程。

## Socket连接过程分析
![socket连接过程](media/15958628546869/socket%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.jpg)

### 服务端
#### socket()
socket()函数的作用就是生成一个用于通信的套接字文件描述符sockfd。这个套接字描述符可以作为稍后bind()函数的绑定对象。

#### bind()函数
服务程序通过分析配置文件，从中解析出想要监听的地址和端口，再加上可以通过socket()函数生成的套接字sockfd，就可以使用bind()函数将这个套接字绑定到要监听的地址和端口组合”addr:port”上。绑定了端口的套接字可以作为listen()函数的监听对象。

#### listen()函数
listen()函数的作用就是监听已经通过bind()函数绑定了addr+port的套接字。监听之后，套接字就从CLOSE状态转变为LISTEN状态，于是这个套接字就可以对外提供TCP连接的窗口了。

若监听了多个地址+端口，即需要监听多个套接字，那么此刻负责监听的进程/线程会采用select()、poll()的方式去轮询这些套接字(当然，也可以使用epoll()模式)，其实只监控一个套接字时，也是使用这些模式去轮询的，只不过select()或poll()所轮询的套接字描述符只有一个而已。具体的步骤如下：

    （1）在进程/线程(监听者)监听的过程中，它阻塞在select()或poll()上。
    （2）当客户端调用connect之后，客户端发起SYN请求，进行第一次握手。服务器端在接受到SYN请求之后，SYN信息被写入到它所监听的sockfd中(即recv buffer)，内核被唤醒(因为TCP三次握手和四次挥手是在内核空间由内核完成的，不涉及用户空间)， 并将SYN数据拷贝到kernel buffer中进行处理(例如判断SYN是否合理)。
    （3）在连接未完成队列(SYN队列)中为这个连接创建一个新项目，并设置为SYN_RECV状态。
    （4）然后准备SYN+ACK数据，这个数据需要从kernel buffer中拷入send buffer中，再拷入网卡传送出去，这称为第二次握手。
    （5）再次使用select()/poll()方式监控着套接字listenfd，直到再次有数据写入这个listenfd中，内核再次被唤醒。
            若写入的数据是ACK信息，表示是某个客户端对服务端内核发送的SYN+ACK的回应，于是将数据拷入到kernel buffer中进行处理后，把连接未完成队列中对应的项目移入连接已完成队列(ACCEPT队列)，并设置为ESTABLISHED状态。
            若接收的不是ACK，则肯定是SYN，即新的连接请求，处理流程和步骤2一致。
            
从上面的步骤可以看出，listen()函数还维护了两个队列：连接未完成队列(SYN队列)和连接已完成队列(ACCEPT队列)。当监听者接收到某个客户端发来的SYN并回复了SYN+ACK之后，就会在未完成连接队列的尾部创建一个关于这个客户端的条目，并设置它的状态为SYN_RECV。显然，这个条目中必须包含客户端的地址和端口相关信息。当服务端再次收到这个客户端发送的ACK信息之后，监听者线程通过分析数据就知道这个消息是回复给未完成连接队列中的哪一项的，于是将这一项移入到已完成连接队列，并设置它的状态为ESTABLISHED，最后等待内核使用accept()函数来消费接收这个连接。从此开始，内核暂时退出舞台，直到4次挥手。 

当未完成连接队列满了，监听者被阻塞不再接收新的连接请求，并通过select()/poll()等待两个队列触发可写事件。当已完成连接队列满了，则监听者也不会接收新的连接请求，同时，正准备移入到已完成连接队列的动作被阻塞。

#### accept()函数
对于已经放入已完成队列中的连接，将等待内核通过accept()函数进行消费(由用户空间进程发起accept()系统调用，由内核完成消费操作)，只要经过accept()过的连接，连接将从已完成队列中移除，并重新建立一个新的sockfd。工作进程/线程就可以通过这个连接套接字和客户端进行数据传输，而监听套接字(sockfd)则仍然被监听者监听。这个socket buffer和监听套接字的socket buffer都是用来存储TCP收、发的数据，但它们的意义已经不再一样：监听套接字的socket buffer只接受TCP连接请求过程中的syn和ack数据；而已建立的TCP连接的socket buffer主要存储的内容是两端传输的”正式”数据，例如服务端构建的响应数据，客户端发起的Http请求数据。

当监听者发起accept()系统调用的时候，如果已完成连接队列中没有任何数据，那么监听者会被阻塞。当然，可将套接字设置为非阻塞模式，这时accept()在得不到数据时会返回EWOULDBLOCK或EAGAIN的错误。可以使用select()或poll()或epoll来等待已完成连接队列的可读事件。还可以将套接字设置为信号驱动IO模式，让已完成连接队列中新加入的数据通知监听者将数据复制到app buffer中并使用accept()进行处理。

#### Recv-Q与Send-Q
netstat命令的Send-Q和Recv-Q列表示的就是socket buffer相关的内容，以下是man netstat的解释。

    （1）对于监听状态的套接字：Recv-Q表示的是当前syn backlog，即堆积的syn消息的个数，也即未完成队列中当前的连接个数，Send-Q表示的是syn backlog的最大值，即未完成连接队列的最大连接限制个数；
    （2）对于已经建立的tcp连接：Recv-Q列表示的是recv buffer中还未被用户进程拷贝走的数据大小，Send-Q列表示的是远程主机还未返回ACK消息的数据大小。

之所以区分已建立TCP连接的套接字和监听状态的套接字，就是因为这两种状态的套接字采用不同的socket buffer，其中监听套接字更注重队列的长度，而已建立TCP连接的套接字更注重收、发的数据大小。

#### syn flood的影响
此外，如果监听者发送SYN+ACK后，迟迟收不到客户端返回的ACK消息，监听者将被select()/poll()设置的超时时间唤醒，并对该客户端重新发送SYN+ACK消息，防止这个消息遗失在茫茫网络中。但是，这一重发就出问题了，如果客户端调用connect()时伪造源地址，那么监听者回复的SYN+ACK消息是一定到不了对方的主机的，也就是说，监听者会迟迟收不到ACK消息，于是重新发送SYN+ACK。但无论是监听者因为select()/poll()设置的超时时间一次次地被唤醒，还是一次次地将数据拷入send buffer，这期间都是需要CPU参与的，而且send buffer中的SYN+ACK还要再拷入网卡(这次是DMA拷贝，不需要CPU)。如果，这个客户端是个攻击者，源源不断地发送了数以千、万计的SYN，监听者几乎直接就崩溃了，网卡也会被阻塞的很严重。这就是所谓的syn flood攻击。

解决syn flood的方法有多种，例如，缩小listen()维护的两个队列的最大长度，减少重发syn+ack的次数，增大重发的时间间隔，减少收到ack的等待超时时间，使用syncookie等，但直接修改tcp选项的任何一种方法都不能很好兼顾性能和效率。所以在连接到达监听者线程之前对数据包进行过滤是极其重要的手段。

### 客户端
#### connect()函数
connect()函数则用于向某个已监听的套接字发起连接请求，也就是发起TCP的三次握手过程。从这里可以看出，连接请求方(如客户端)才会使用connect()函数，当然，在发起connect()之前，连接发起方也需要生成一个sockfd，且使用的很可能是绑定了随机端口的套接字。既然connect()函数是向某个套接字发起连接的，自然在使用connect()函数时需要带上连接的目的地，即目标地址和目标端口，这正是服务端的监听套接字上绑定的地址和端口。同时，它还要带上自己的地址和端口，对于服务端来说，这就是连接请求的源地址和源端口。于是，TCP连接的两端的套接字都已经成了五元组的完整格式。

### tcp连接和套接字的关系
每个tcp连接的两端都会关联一个套接字和该套接字指向的文件描述符。当服务端收到了ack消息后，就表示三次握手完成了，表示和客户端的这个tcp连接已经建立好了。连接建立好的一开始，这个tcp连接会放在listen()打开的established queue队列中等待accept()的消费。这个时候的tcp连接在服务端所关联的套接字是listen套接字和它指向的文件描述符。

当established queue中的tcp连接被accept()消费后，这个tcp连接就会关联accept()所指定的套接字，并分配一个新的文件描述符。也就是说，经过accept()之后，这个连接和listen套接字已经没有任何关系了。

![tcp与套接字](media/15958628546869/tcp%E4%B8%8E%E5%A5%97%E6%8E%A5%E5%AD%97.jpg)

换句话说，连接还是那个连接，只不过服务端偷偷地换掉了这个tcp连接所关联的套接字和文件描述符，而客户端并不知道这一切。但这并不影响双方的通信，因为数据传输是基于连接而不是基于套接字的，只要能从文件描述符中将数据放入tcp连接这根”管道”里，数据就能到达另一端。

实际上，并不一定需要accept()才能进行tcp通信，因为在accept()之前连接就以建立好了，只不过它关联的是listen套接字对应的文件描述符，而这个套接字只识别三次握手和四次挥手涉及到的数据，而且这个套接字中的数据是由操作系统内核负责的。可以想像一下，只有listen()没有accept()时，客户端不断地发起connect()，服务端将一直将建立仅只连接而不做任何操作，直到listen的队列满了。

### send()和recv()函数
send()函数是将数据从app buffer复制到send buffer中(当然，也可能直接从内核的kernel buffer中复制)，recv()函数则是将recv buffer中的数据复制到app buffer中。当然，对于tcp套接字来说，更多的是使用write()和read()函数来发送、读取socket buffer数据，这里使用send()/recv()来说明仅仅只是它们的名称针对性更强而已。

这两个函数都涉及到了socket buffer，但是在调用send()或recv()时，复制的源buffer中是否有数据、复制的目标buffer中是否已满而导致不可写是需要考虑的问题。不管哪一方，只要不满足条件，调用send()/recv()时进程/线程会被阻塞(假设套接字设置为阻塞式IO模型)。当然，可以将套接字设置为非阻塞IO模型，这时在buffer不满足条件时调用send()/recv()函数，调用函数的进程/线程将返回错误状态信息EWOULDBLOCK或EAGAIN。buffer中是否有数据、是否已满而导致不可写，其实可以使用select()/poll()/epoll去监控对应的文件描述符(对应socket buffer则监控该socket描述符)，当满足条件时，再去调用send()/recv()就可以正常操作了。还可以将套接字设置为信号驱动IO或异步IO模型，这样数据准备好、复制好之前就不用再做无用功去调用send()/recv()了。


### close()、shutdown()函数
通用的close()函数可以关闭一个文件描述符，当然也包括面向连接的网络套接字描述符。当调用close()时，将会尝试发送send buffer中的所有数据。但是close()函数只是将这个套接字引用计数减1，就像rm一样，删除一个文件时只是移除一个硬链接数，只有这个套接字的所有引用计数都被删除，套接字描述符才会真的被关闭，才会开始后续的四次挥手中。对于父子进程共享套接字的并发服务程序，调用close()关闭子进程的套接字并不会真的关闭套接字，因为父进程的套接字还处于打开状态，如果父进程一直不调用close()函数，那么这个套接字将一直处于打开状态，将一直进入不了四次挥手过程。

而shutdown()函数专门用于关闭网络套接字的连接，和close()对引用计数减一不同的是，它直接掐断套接字的所有连接，从而引发四次挥手的过程。可以指定3种关闭方式：

    （1）关闭写。此时将无法向send buffer中再写数据，send buffer中已有的数据会一直发送直到完毕。
    （2）关闭读。此时将无法从recv buffer中再读数据，recv buffer中已有的数据只能被丢弃。
    （3）关闭读和写。此时无法读、无法写，send buffer中已有的数据会发送直到完毕，但recv buffer中已有的数据将被丢弃。

无论是shutdown()还是close()，每次调用它们，在真正进入四次挥手的过程中，它们都会发送一个FIN。

## 总结
![socket客户端服务端流程总结](media/15958628546869/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93.gif)









