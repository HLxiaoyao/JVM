# 三色标记算法
之前介绍了标记清理与标记整理等垃圾清理算法，不管是哪种算法，第一步都是标记。而现在例如CMS、G1等垃圾收集器在标记阶段都是采用应用程序线程与垃圾回收线程并发执行（并发标记），而三色标记法就是为了解决Mutator（应用程序）与Collector(主要是垃圾收集器标记阶段) 不能并发执行的问题。

## 基本算法
![](/images/三色标记算法1.png)

![](/images/三色标记算法2.png)

三色标记算法的基本原理就是把遍历对象过程中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：

    （1）白色：尚未访问过。
    （2）黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问过了。
             (自己标记完了，自己的孩子（包括多个孩子）也标记完了，都不是垃圾)
    （3）灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问完。
             全部访问后，会转换为黑色。(自己标记完了，自己的孩子（包括多个孩子）没有标记)

![](/images/三色标记算法3.png)

假设有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：

    （1）初始时，所有对象都在白色集合中；
    （2）将GC Roots直接引用到的对象挪到灰色集合中；
    （3）从灰色集合中获取对象：
            将本对象引用到的其他对象全部挪到灰色集合中；
            将本对象挪到黑色集合里面；
    （4）重复步骤3，直至灰色集合为空时结束。
    （5）遍历结束后，仍在白色集合的对象即为GC Roots不可达，可以进行回收。
    
注意：若标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。当Stop The World时，对象间的引用是不会发生变化的，可以轻松完成标记。而当需要支持并发标记时，即标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。

## 多标-浮动垃圾
![](/images/三色标记算法-多标.png)

如上图，若遍历到E（变为灰色了），此时应用程序执行了objD.fieldE = null。那么对象E/F/G是“应该”被回收的。然而因为E已经变为灰色了，其仍会被当作存活对象继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即本轮GC不会回收这部分内存。

这部分本应该回收，但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。

另外，针对并发标记开始后的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。

## 漏标-读写屏障
![](/images/三色标记算法-漏标.png)

```
var G = objE.fieldG; 
// 灰色E 断开引用 白色G 
objE.fieldG = null;  
// 黑色D 引用 白色G
objD.fieldG = G;
```  
如上图，若GC线程已经遍历到E（变为灰色了），此时应用线程先执行了上述代码。然后切回GC线程继续跑，因为E已经没有对G的引用了，所以不会将G放到灰色集合；尽管因为D重新引用了G，但因为D已经是黑色了，不会再重新做遍历处理。

最终导致的结果是：G会一直停留在白色集合中，最后被当作垃圾进行清除。这直接影响到了应用程序的正确性，是不可接受的。不难分析，漏标只有同时满足以下两个条件时才会发生：

    （1）条件一：灰色对象断开了白色对象的引用；即灰色对象原来成员变量的引用发生了变化。
    （2）条件二：黑色对象重新引用了该白色对象；即黑色对象成员变量增加了新的引用。
    
从代码的角度看：
```
var G = objE.fieldG; // 1.读
objE.fieldG = null;  // 2.写
objD.fieldG = G;     // 3.写
```

    （1）读取对象E的成员变量fieldG的引用值，即对象G；
    （2）对象E往其成员变量fieldG，写入null值。
    （3）对象D往其成员变量fieldG，写入对象G ；
    
其实只要在上面这三步中的任意一步中做一些“手脚”，将对象G记录起来，然后作为灰色对象再进行遍历即可。例如放到一个特定的集合，等初始的GC Roots遍历完（并发标记），该集合的对象遍历即可（重新标记）。

但是重新标记是需要STW的，因为应用程序一直在跑的话，该集合可能会一直增加新的对象，导致永远都跑不完。当然，并发标记期间也可以将该集合中的大部分先跑了，从而缩短重新标记STW的时间，这个是优化问题了。

写屏障用于拦截第二和第三步；而读屏障则是拦截第一步。它们的拦截的目的很简单：就是在读写前后，将对象G给记录下来。

## CMS解决方案
CMS为了解决三色标记算法存在的多标与漏标问题，采用写屏障 + 增量更新的方案对三色标记算法进行了优化。
### 增量更新
![](/images/三色标记算法-增量更新.png)

如上图，刚开始开始B指向D，但是因为后来B不指向D了，由A执行D了，最简单的方法是将A变成灰色，等待下次进行再次遍历。这就是增量更新的逻辑。即当一个白色对象被一个黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。但是增量更新存在如下问题：

![](/images/三色标记算分-增量更新ABA.png)

### 写屏障（Store Barrier）
给某个对象的成员变量赋值时，其底层代码大概如下：
```
/**
* @param field某对象的成员变量，如D.fieldG
* @param new_value 新值，如null
*/
void oop_field_store(oop* field, oop new_value) { 
    // 赋值操作
    *field = new_value; 
} 
```
而写屏障其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）：
```
void oop_field_store(oop* field, oop new_value) {
     // 写屏障-写前操作  
    pre_write_barrier(field);
    *field = new_value; 
    // 写屏障-写后操作
    post_write_barrier(field, value);  
}
```
### 写屏障+增量更新
下面介绍一下CMS的写屏障+增量更新的方案，当对象D的成员变量的引用发生变化时（objD.fieldG = G;），可以利用写屏障，将D新的成员变量引用对象G记录下来：
```
void post_write_barrier(oop* field, oop new_value) {  
  if($gc_phase == GC_CONCURRENT_MARK && !isMarkd(field)) {
      remark_set.add(new_value); // 记录新引用的对象
  }
}
```
总结一句话：当有新引用插入进来时，记录下新的引用对象。这种做法的思路是：不要求保留原始快照，而是针对新增的引用，将其记录下来等待遍历，即增量更新（Incremental Update）。增量更新破坏了条件二：黑色对象重新引用了该白色对象，从而保证了不会漏标。

## G1解决方案
G1为了解决三色标记算法存在的多标与漏标问题，采用写屏障 + SATB的方案对三色标记算法进行了优化。

### 写屏障+SATB
当对象E的成员变量的引用发生变化时（objE.fieldG = null;），可以利用写屏障，将E原来成员变量的引用对象G记录下来：
```
void pre_write_barrier(oop* field) {
    oop old_value = *field; // 获取旧值
    remark_set.add(old_value); // 记录 原来的引用对象
}
```
总结一句话：当原来成员变量的引用发生变化之前，记录下原来的引用对象。这种做法的思路是：尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB），当某个时刻的GC Roots确定后，当时的对象图就已经确定了。SATB破坏了条件一：灰色对象断开了白色对象的引用，从而保证了不会漏标。

例如当时D是引用着G的，那后续的标记也应该是按照这个时刻的对象图走（D引用着G）。如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。

但是扫描所有GC Roots这个操作（即初始标记）通常是需要STW的，否则有可能永远都扫不完，因为并发期间可能增加新的GC Roots。

一点小优化：若不是处于垃圾回收的并发标记阶段，或者已经被标记过了，其实是没必要再记录了，所以可以加个简单的判断：
```
void pre_write_barrier(oop* field) {
  // 处于GC并发标记阶段 且 该对象没有被标记（访问）过
  if($gc_phase == GC_CONCURRENT_MARK && !isMarkd(field)) { 
      oop old_value = *field; // 获取旧值
      remark_set.add(old_value); // 记录  原来的引用对象
  }
}
```
## ZGC解决方案
ZGC为了解决三色标记算法存在的多标与漏标问题，采用读屏障的方案对三色标记算法进行了优化。

![](/images/三色标记算法-读屏障.png)

Remapped是对象在转移，所以这里要读的时候，先等待对象转移完成。
```
oop oop_field_load(oop* field) {
    pre_load_barrier(field); // 读屏障-读取前操作
    return *field;
}
```
读屏障是直接针对第一步：var G = objE.fieldG;，当读取成员变量时，一律记录下来：
```
void pre_load_barrier(oop* field, oop old_value) {  
  if($gc_phase == GC_CONCURRENT_MARK && !isMarkd(field)) {
      oop old_value = *field;
      remark_set.add(old_value); // 记录读取到的对象
  }
}
```
这种做法是保守的，但也是安全的。因为条件二中黑色对象重新引用了该白色对象，重新引用的前提是：得获取到该白色对象，此时已经读屏障就发挥作用了。